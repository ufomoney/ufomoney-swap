{"code":"import invariant from 'tiny-invariant';\r\nimport { ChainId } from '../constants';\r\nimport { validateAndParseAddress } from '../utils';\r\nimport { Currency } from './currency';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport class Token extends Currency {\r\n    constructor(chainId, address, decimals, symbol, name) {\r\n        super(decimals, symbol, name);\r\n        this.chainId = chainId;\r\n        this.address = validateAndParseAddress(address);\r\n    }\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other) {\r\n        // short circuit on reference equality\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        return this.chainId === other.chainId && this.address === other.address;\r\n    }\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other) {\r\n        invariant(this.chainId === other.chainId, 'CHAIN_IDS');\r\n        invariant(this.address !== other.address, 'ADDRESSES');\r\n        return this.address.toLowerCase() < other.address.toLowerCase();\r\n    }\r\n}\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport function currencyEquals(currencyA, currencyB) {\r\n    if (currencyA instanceof Token && currencyB instanceof Token) {\r\n        return currencyA.equals(currencyB);\r\n    }\r\n    else if (currencyA instanceof Token) {\r\n        return false;\r\n    }\r\n    else if (currencyB instanceof Token) {\r\n        return false;\r\n    }\r\n    else {\r\n        return currencyA === currencyB;\r\n    }\r\n}\r\nexport const WETH = {\r\n    [ChainId.MAINNET]: new Token(ChainId.MAINNET, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'),\r\n    [ChainId.ROPSTEN]: new Token(ChainId.ROPSTEN, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'),\r\n    [ChainId.RINKEBY]: new Token(ChainId.RINKEBY, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'),\r\n    [ChainId.GÖRLI]: new Token(ChainId.GÖRLI, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'),\r\n    [ChainId.KOVAN]: new Token(ChainId.KOVAN, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'),\r\n    [ChainId.BSC_MAINNET]: new Token(ChainId.BSC_MAINNET, '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', 18, 'WBNB', 'Wrapped BNB'),\r\n    [ChainId.BSC_TESTNET]: new Token(ChainId.BSC_TESTNET, '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', 18, 'WBNB', 'Wrapped BNB')\r\n};\r\n//# sourceMappingURL=token.js.map","references":["/root/work/uniswap/SwapLiquidity-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/root/work/uniswap/SwapLiquidity-sdk/src/constants.ts","/root/work/uniswap/SwapLiquidity-sdk/src/utils.ts","/root/work/uniswap/SwapLiquidity-sdk/src/entities/currency.ts"],"map":"{\"version\":3,\"file\":\"token.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/entities/token.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/root/work/uniswap/SwapLiquidity-sdk/src/entities/token.d.ts","writeByteOrderMark":false,"text":"import { ChainId } from '../constants';\r\nimport { Currency } from './currency';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport declare class Token extends Currency {\r\n    readonly chainId: ChainId;\r\n    readonly address: string;\r\n    constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string);\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other: Token): boolean;\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other: Token): boolean;\r\n}\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport declare function currencyEquals(currencyA: Currency, currencyB: Currency): boolean;\r\nexport declare const WETH: {\r\n    1: Token;\r\n    3: Token;\r\n    4: Token;\r\n    5: Token;\r\n    42: Token;\r\n    56: Token;\r\n    97: Token;\r\n};\r\n"}}
